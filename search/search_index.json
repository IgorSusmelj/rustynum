{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-rustynum","title":"Welcome to RustyNum!","text":"<p>RustyNum is a high-performance numerical computation library written in Rust, designed to be faster, lighter, and simpler than traditional solutions. With seamless Python bindings, RustyNum empowers developers and data scientists to achieve efficient computation with minimal overhead.</p>"},{"location":"#what-is-rustynum","title":"\ud83d\ude80 What is RustyNum?","text":"<p>RustyNum is built to demonstrate the potential of Rust's SIMD capabilities while providing a NumPy-like interface for Python users. Whether you're working on machine learning, data analysis, or scientific computing, RustyNum offers:</p> <ul> <li>Up to 2.86x faster computations than NumPy for key operations.</li> <li>Lightweight and portable Python wheels (300 KB vs. NumPy\u2019s ~15 MB).</li> <li>Minimal dependencies, ensuring quick and easy deployment.</li> </ul>"},{"location":"#key-features","title":"\ud83c\udfc6 Key Features","text":""},{"location":"#high-performance","title":"High Performance","text":"<ul> <li>Utilizes Rust's <code>portable_simd</code> for lightning-fast computations.</li> <li>Optimized for matrix and vector operations, with support for advanced numerical tasks.</li> <li>Matrix operations use additional multithreading for parallelization. Multithreading is currently not supported for any other operations.</li> </ul>"},{"location":"#seamless-python-integration","title":"Seamless Python Integration","text":"<ul> <li>Python bindings offer a familiar interface for NumPy users.</li> <li>Compatible with popular Python versions (3.8 - 3.12).</li> </ul>"},{"location":"#lightweight-and-portable","title":"Lightweight and Portable","text":"<ul> <li>No external Rust crates used\u2014keeping the codebase simple and transparent.</li> <li>Tiny footprint ensures quick installations and smooth deployments.</li> </ul>"},{"location":"#get-started-with-rustynum","title":"\ud83d\udcda Get Started with RustyNum","text":"<p>Ready to explore RustyNum? Here\u2019s how you can dive in:</p> <ol> <li>Installation: Install RustyNum with a single <code>pip</code> command.</li> <li>Quick Start: Learn the basics of using RustyNum.</li> <li>Tutorials: Explore real-world examples and advanced guides.</li> <li>API Reference: Dive deep into RustyNum\u2019s Python API.</li> </ol>"},{"location":"#why-rustynum","title":"\ud83c\udf1f Why RustyNum?","text":"<ul> <li>Speed: Perform computations faster than NumPy.</li> <li>Familiarity: Built with Python users in mind\u2014no steep learning curve.</li> <li>Flexibility: Ideal for machine learning, data preprocessing, and scientific research.</li> <li>Open Source: Contribute and be part of a growing community.</li> </ul>"},{"location":"#contribute","title":"\ud83e\udd1d Contribute","text":"<p>RustyNum is open source and powered by contributors like you! Whether you\u2019re a developer, data scientist, or enthusiast, your input matters.</p> <ul> <li>GitHub Repository: Explore the codebase, report issues, or submit pull requests.</li> <li>Join the Community: Share ideas, ask questions, or propose features.</li> </ul>"},{"location":"#stay-updated","title":"\ud83d\udce9 Stay Updated","text":"<p>Follow our journey and stay updated on RustyNum's latest developments:</p> <ul> <li>Star our GitHub repository to support the project!</li> </ul> Get Started Contribute on GitHub"},{"location":"installation/","title":"Installation Guide","text":"<p>Get started with RustyNum by following this installation guide. Whether you're using Python for data analysis or contributing to the core library, this page covers everything you need.</p>"},{"location":"installation/#supported-platforms-and-versions","title":"\u2705 Supported Platforms and Versions","text":""},{"location":"installation/#supported-python-versions","title":"Supported Python Versions","text":"<ul> <li>Python 3.8, 3.9, 3.10, 3.11, 3.12</li> </ul>"},{"location":"installation/#supported-operating-systems","title":"Supported Operating Systems","text":"<ul> <li>Windows: x86</li> <li>Linux: x86</li> <li>MacOS: x86 &amp; ARM (Apple Silicon support)</li> </ul>"},{"location":"installation/#installation-options","title":"\ud83d\udce6 Installation Options","text":""},{"location":"installation/#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>The easiest way to install RustyNum is via PyPI:</p> <pre><code>pip install rustynum\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<p>To install RustyNum using Poetry, run:</p> <pre><code>poetry add rustynum\n</code></pre>"},{"location":"installation/#using-rye","title":"Using Rye","text":"<p>To add RustyNum to your Rye project:</p> <pre><code>rye add rustynum\n</code></pre>"},{"location":"installation/#using-conda","title":"Using Conda","text":"<p>To install RustyNum in a conda environment, first activate your environment and then use pip:</p> <pre><code>conda activate your-environment\npip install rustynum\n</code></pre>"},{"location":"installation/#verify-the-installation","title":"Verify the Installation","text":"<p>Test your installation by running the following Python code:</p> <pre><code>import rustynum as rnp\n\na = rnp.zeros([2, 3])\nprint(a)\n</code></pre> <p>If the installation is successful, you should see the output:</p> <pre><code>[[0. 0. 0.]\n [0. 0. 0.]]\n</code></pre>"},{"location":"quick-start/","title":"Getting Started with RustyNum","text":"<p>Welcome to RustyNum! This guide will help you quickly get up and running with RustyNum, from basic operations to a comparison with NumPy. If you're familiar with NumPy, you'll feel right at home.</p>"},{"location":"quick-start/#why-use-rustynum","title":"\ud83d\udd25 Why Use RustyNum?","text":"<p>RustyNum is a high-performance alternative to NumPy. With Rust\u2019s SIMD optimization, RustyNum can significantly speed up your numerical computations, all while maintaining a familiar interface.</p>"},{"location":"quick-start/#basic-usage","title":"\ud83d\udcd8 Basic Usage","text":"<p>Here\u2019s a quick example to demonstrate RustyNum's simplicity and performance:</p>"},{"location":"quick-start/#example-compute-the-mean-of-an-array","title":"Example: Compute the Mean of an Array","text":"<pre><code>import rustynum as rnp\n\n# Create a NumArray\na = rnp.NumArray([1.0, 2.0, 3.0, 4.0], dtype=\"float32\")\n\n# Add a scalar\na = a + 2\n\n# Compute the mean\nmean_value = a.mean().item()\n\nprint(mean_value)  # Output: 4.5\n</code></pre>"},{"location":"quick-start/#rustynum-vs-numpy","title":"\u26a1 RustyNum vs NumPy","text":"<p>RustyNum is designed to be a faster alternative to NumPy for many operations. Let\u2019s compare the syntax:</p>"},{"location":"quick-start/#creating-arrays","title":"Creating Arrays","text":""},{"location":"quick-start/#numpy","title":"NumPy","text":"<pre><code>import numpy as np\n\na = np.array([1.0, 2.0, 3.0], dtype=\"float32\")\n</code></pre>"},{"location":"quick-start/#rustynum","title":"RustyNum","text":"<pre><code>import rustynum as rnp\n\na = rnp.NumArray([1.0, 2.0, 3.0], dtype=\"float32\")\n</code></pre>"},{"location":"quick-start/#adding-scalars","title":"Adding Scalars","text":""},{"location":"quick-start/#numpy_1","title":"NumPy","text":"<pre><code>a = a + 2\n</code></pre>"},{"location":"quick-start/#rustynum_1","title":"RustyNum","text":"<pre><code>a = a + 2\n</code></pre>"},{"location":"quick-start/#computing-the-mean","title":"Computing the Mean","text":""},{"location":"quick-start/#numpy_2","title":"NumPy","text":"<pre><code>mean_value = a.mean()\n</code></pre>"},{"location":"quick-start/#rustynum_2","title":"RustyNum","text":"<pre><code>mean_value = a.mean().item()\n</code></pre>"},{"location":"quick-start/#basic-operations","title":"\ud83d\udee0\ufe0f Basic Operations","text":"<p>RustyNum supports a variety of operations. Here are a few examples to get you started:</p>"},{"location":"quick-start/#1-creating-arrays","title":"1. Creating Arrays","text":"<pre><code>import rustynum as rnp\n\n# Create an array of zeros\nzeros_array = rnp.zeros([3, 3])\n\n# Create an array with evenly spaced values\narange_array = rnp.arange(0, 10, 2)\n\n# Create an array with evenly spaced values over a specified interval\nlinspace_array = rnp.linspace(0, 1, 5)\n\nprint(zeros_array)\nprint(arange_array)\nprint(linspace_array)\n</code></pre>"},{"location":"quick-start/#2-element-wise-operations","title":"2. Element-Wise Operations","text":"<pre><code># Perform element-wise addition\nresult = arange_array + 2\n\n# Perform element-wise multiplication\nresult = arange_array * 2\n</code></pre>"},{"location":"quick-start/#3-matrix-operations","title":"3. Matrix Operations","text":"<pre><code># Create a 2D NumArray\nmatrix = rnp.NumArray([[1.0, 2.0], [3.0, 4.0]], dtype=\"float32\")\n\n# Compute the dot product\nvector = rnp.NumArray([1.0, 2.0], dtype=\"float32\")\ndot_product = matrix.dot(vector)\n\nprint(dot_product)\n</code></pre>"},{"location":"quick-start/#learn-more","title":"\ud83d\udd17 Learn More","text":"<p>Once you\u2019re comfortable with the basics, dive deeper into RustyNum with these resources:</p> <ul> <li>Tutorials: Explore real-world applications of RustyNum.</li> <li>API Reference: Detailed documentation of RustyNum\u2019s Python bindings.</li> </ul>"},{"location":"quick-start/#need-help","title":"\ud83d\udce9 Need Help?","text":"<p>If you have any questions, check out our GitHub Discussions or file an issue on our GitHub Repository.</p> Explore Tutorials View API Reference"},{"location":"api/","title":"Python API Reference","text":""},{"location":"api/#classes","title":"Classes","text":""},{"location":"api/#numarray","title":"NumArray","text":""},{"location":"api/#rustynum.NumArray.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Returns the shape of the array as a tuple, similar to numpy.ndarray.shape.</p>"},{"location":"api/#rustynum.NumArray.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds another NumArray or a scalar to the NumArray.</p> <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray with the result of the addition.</p>"},{"location":"api/#rustynum.NumArray.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Gets the item(s) at the specified index or slice.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[int, slice]</code> <p>Index or slice for the item(s) to get.</p> required <p>Returns:</p> Type Description <code>Union[List[float], NumArray]</code> <p>Single item or a new NumArray with the sliced data.</p>"},{"location":"api/#rustynum.NumArray.__imul__","title":"<code>__imul__(scalar)</code>","text":"<p>In-place multiplication by a scalar.</p>"},{"location":"api/#rustynum.NumArray.__init__","title":"<code>__init__(data, dtype=None)</code>","text":"<p>Initializes a NumArray object with the given data and data type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[List[float], List[int], NumArray]</code> <p>List of numerical data or existing NumArray.</p> required <code>dtype</code> <code>Union[None, str]</code> <p>Data type of the numerical data ('int32', 'int64', 'float32' or 'float64'). If None, dtype is inferred.</p> <code>None</code>"},{"location":"api/#rustynum.NumArray.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplies the NumArray by another NumArray or a scalar.</p> <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray with the result of the multiplication.</p>"},{"location":"api/#rustynum.NumArray.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtracts another NumArray or a scalar from the NumArray.</p> <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray with the result of the subtraction.</p>"},{"location":"api/#rustynum.NumArray.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Divides the NumArray by another NumArray or a scalar.</p> <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray with the result of the division.</p>"},{"location":"api/#rustynum.NumArray.dot","title":"<code>dot(other)</code>","text":"<p>Computes the dot product or matrix multiplication with another NumArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NumArray</code> <p>Another NumArray to compute the dot product with.</p> required <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray containing the result of the dot product or matrix multiplication.</p>"},{"location":"api/#rustynum.NumArray.max","title":"<code>max()</code>","text":"<p>Finds the maximum value in the NumArray.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum value as a float.</p>"},{"location":"api/#rustynum.NumArray.mean","title":"<code>mean(axes=None)</code>","text":"<p>Computes the mean of the NumArray along specified axes.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Union[None, int, Sequence[int]]</code> <p>Optional; Axis or axes along which to compute the mean. If None, the mean   of all elements is computed as a scalar.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[NumArray, float]</code> <p>A new NumArray with the mean values along the specified axes, or a scalar if no axes are given.</p>"},{"location":"api/#rustynum.NumArray.min","title":"<code>min()</code>","text":"<p>Finds the minimum value in the NumArray.</p> <p>Returns:</p> Type Description <code>float</code> <p>The minimum value as a float.</p>"},{"location":"api/#rustynum.NumArray.reshape","title":"<code>reshape(shape)</code>","text":"<p>Reshapes the NumArray to the specified shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>List[int]</code> <p>New shape for the NumArray.</p> required <p>Returns:</p> Type Description <code>NumArray</code> <p>A new NumArray with the reshaped data.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"tutorials/","title":"RustyNum Tutorials","text":"<ul> <li>Getting Better Matrix Operations with RustyNum</li> <li>Replacing Core NumPy Calls for Faster Analytics</li> </ul>"},{"location":"tutorials/better-matrix-operations/","title":"Getting Better Matrix Operations with RustyNum","text":"<p>Matrix operations are at the core of many data science and engineering workflows. When performance matters, switching from traditional Python solutions to RustyNum can be a great move. In this tutorial, you\u2019ll learn how to perform matrix-vector and matrix-matrix operations with RustyNum, compare them to NumPy, and see how SIMD acceleration can improve efficiency.</p>"},{"location":"tutorials/better-matrix-operations/#why-matrix-operations-matter","title":"Why Matrix Operations Matter","text":"<p>Matrix operations are fundamental to: - Machine Learning and Deep Neural Networks - Scientific Computing and Simulations - Image Processing and Computer Vision - Financial Modeling and Statistics</p> <p>RustyNum leverages Rust's SIMD capabilities to provide significant performance improvements over traditional Python solutions, achieving up to 2.86x speedup for certain operations compared to NumPy.</p>"},{"location":"tutorials/better-matrix-operations/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>If you haven\u2019t already installed RustyNum, visit the Installation Guide. Once you have RustyNum set up, verify it works by creating a small NumArray and printing its contents:</p> <pre><code>import rustynum as rnp\n\nsample = rnp.NumArray([1.0, 2.0, 3.0], dtype=\"float32\")\nprint(\"Sample array:\", sample)\n</code></pre> <p>You should see an output reflecting your new array.  </p> <pre><code>Sample array: [1. 2. 3.]\n</code></pre>"},{"location":"tutorials/better-matrix-operations/#matrix-vector-multiplication","title":"Matrix-Vector Multiplication","text":"<p>Matrix-vector multiplication is one of the most common tasks in numerical computing. It\u2019s often used in transformations, linear regression, and more.</p>"},{"location":"tutorials/better-matrix-operations/#creating-a-matrix-and-vector","title":"Creating a Matrix and Vector","text":"<pre><code>import rustynum as rnp\n\n# Create a 4x4 matrix\nmatrix_data = [i for i in range(16)]  # 0 to 15\nmatrix = rnp.NumArray(matrix_data, dtype=\"float32\").reshape([4, 4])\n\n# Create a 4-element vector\nvector_data = [1, 2, 3, 4]\nvector = rnp.NumArray(vector_data, dtype=\"float32\")\n\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\\n\", vector)\n</code></pre> <p>In this example, we reshape a 1D list into a 4\u00d74 matrix. RustyNum\u2019s <code>reshape</code> method is similar to NumPy\u2019s.</p>"},{"location":"tutorials/better-matrix-operations/#performing-the-multiplication","title":"Performing the Multiplication","text":"<pre><code>result_vec = matrix.dot(vector)\nprint(\"Matrix-Vector Multiplication Result:\\n\", result_vec)\n</code></pre> <p>RustyNum\u2019s <code>.dot()</code> function handles both matrix-vector and matrix-matrix products based on the shapes of the inputs.</p> <p>Alternatively, you can use the <code>@</code> operator for matrix multiplication:</p> <pre><code>result_vec = matrix @ vector\nprint(\"Matrix-Vector Multiplication Result:\\n\", result_vec)\n</code></pre> <p>Matrix Multiplication Operator</p> <p>RustyNum supports Python's <code>@</code> operator for matrix multiplication, which is the recommended way to perform matrix-vector and matrix-matrix operations. It follows the same rules as NumPy: the inner dimensions must match, or you'll get an error.</p>"},{"location":"tutorials/better-matrix-operations/#matrix-matrix-multiplication","title":"Matrix-Matrix Multiplication","text":"<p>Matrix-matrix multiplication is more computationally intense than matrix-vector multiplication, and it appears in neural networks, image transformations, and various numerical algorithms.</p>"},{"location":"tutorials/better-matrix-operations/#creating-two-matrices","title":"Creating Two Matrices","text":"<pre><code>import rustynum as rnp\n\n# Create two 2D NumArrays\ndataA = [1.0, 2.0, 3.0, 4.0]\ndataB = [5.0, 6.0, 7.0, 8.0]\n\nA = rnp.NumArray(dataA, dtype=\"float32\").reshape([2, 2])\nB = rnp.NumArray(dataB, dtype=\"float32\").reshape([2, 2])\n\nprint(\"Matrix A:\\n\", A)\nprint(\"Matrix B:\\n\", B)\n</code></pre>"},{"location":"tutorials/better-matrix-operations/#multiplying-the-matrices","title":"Multiplying the Matrices","text":"<pre><code>result_matrix = A.dot(B)\nprint(\"Matrix-Matrix Multiplication Result:\\n\", result_matrix)\n</code></pre> <p>Similar to matrix-vector multiplication, you can use the <code>@</code> operator for matrix multiplication:</p> <pre><code>result_matrix = A @ B\nprint(\"Matrix-Matrix Multiplication Result:\\n\", result_matrix)\n</code></pre> <p>Matrix Multiplication Operator</p> <p>RustyNum supports Python's <code>@</code> operator for matrix multiplication, which is the recommended way to perform matrix-vector and matrix-matrix operations. It follows the same rules as NumPy: the inner dimensions must match, or you'll get an error.</p>"},{"location":"tutorials/better-matrix-operations/#side-by-side-comparison-with-numpy","title":"Side-by-Side Comparison with NumPy","text":"<p>If you want to compare code or performance, you can do so easily:</p> <pre><code>import numpy as np\nimport rustynum as rnp\nimport time\n\n# NumPy multiplication\nmatrix_np = np.arange(16, dtype=np.float32).reshape((4, 4))\nvector_np = np.array([1, 2, 3, 4], dtype=np.float32)\n\nstart_np = time.time()\nresult_np = np.dot(matrix_np, vector_np)\nend_np = time.time()\nnumpy_time = end_np - start_np\n\n# RustyNum multiplication\nmatrix_rn = rnp.NumArray(matrix_np.flatten().tolist(), dtype=\"float32\").reshape([4, 4])\nvector_rn = rnp.NumArray(vector_np.tolist(), dtype=\"float32\")\n\nstart_rn = time.time()\nresult_rn = matrix_rn.dot(vector_rn)\nend_rn = time.time()\nrustynum_time = end_rn - start_rn\n\nprint(\"NumPy result:\", result_np)\nprint(\"RustyNum result:\", result_rn)\nprint(f\"NumPy time: {numpy_time:.6f} seconds\")\nprint(f\"RustyNum time: {rustynum_time:.6f} seconds\")\n</code></pre> <p>On my MacBook Pro M1, this is the output:</p> <pre><code>NumPy result: [ 20.  60. 100. 140.]\nRustyNum result: [20.0, 60.0, 100.0, 140.0]\nNumPy time: 0.000015 seconds\nRustyNum time: 0.000002 seconds\n</code></pre> <p>While timing results can vary based on hardware and environment, RustyNum may offer speed improvements in certain operations.</p>"},{"location":"tutorials/better-matrix-operations/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>SIMD Utilization: RustyNum uses Rust\u2019s nightly <code>portable_simd</code> feature to speed up calculations. This can lead to better throughput on supported hardware (using AVX2, AVX512 for x86, NEON for ARM etc.).</li> <li>Matrix Size: Small matrices may not highlight performance gains because overhead can dominate. Larger matrices typically see more benefit.</li> <li>Data Types: RustyNum currently supports float32, float64, and some integer types. Mixed data types may cause errors or reduced performance.</li> </ol>"},{"location":"tutorials/better-matrix-operations/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<ul> <li>Shape Mismatch: RustyNum will raise an error if matrix dimensions are incompatible. Double-check shapes with <code>.shape</code>.</li> <li>Unsupported Data Type: If you try to create a NumArray with an unsupported type, you might see a ValueError. Stick to float32, float64, or supported integer types.</li> <li>Installation Problems: Confirm you have the right Python version and platform by revisiting the Installation Guide.</li> </ul>"},{"location":"tutorials/better-matrix-operations/#next-steps","title":"Next Steps","text":"<ul> <li>Check out our API Reference for a complete list of functions and classes.</li> <li>Explore more advanced examples in our upcoming Tutorials.</li> <li>Contribute your own ideas or ask questions on our GitHub.</li> </ul> <p>Matrix operations are a cornerstone of computational tasks, and RustyNum offers a Python-friendly path to faster, more efficient code. By tapping into Rust\u2019s low-level optimizations, you can scale your projects without changing your entire workflow.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/","title":"Replacing Core NumPy Calls for Faster Analytics","text":"<p>Many developers rely on NumPy for array operations, statistical calculations, and linear algebra. RustyNum offers an alternative for several common NumPy routines, potentially speeding up your Python analytics. In this tutorial, you\u2019ll see how to replace selected NumPy calls with RustyNum equivalents, measure performance differences, and integrate RustyNum into existing data workflows.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#introduction","title":"Introduction","text":"<p>NumPy is the go-to library for Python numerical tasks, but sometimes you need extra speed. RustyNum taps into Rust\u2019s SIMD capabilities for faster computations in certain scenarios. By strategically swapping out a few operations, you might see noticeable performance gains in your Python scripts.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#why-replace-numpy-calls","title":"Why Replace NumPy Calls?","text":"<ol> <li>Performance Gains: RustyNum\u2019s internal operations are optimized using low-level instructions, which can result in faster execution on supported hardware.</li> <li>Seamless Integration: The interface is similar to NumPy, so transitions often involve minimal code changes.</li> <li>Lightweight: RustyNum wheels are much smaller (300kB vs 15MB for NumPy), making installation and distribution simpler.</li> </ol>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#benchmark-setup","title":"Benchmark Setup","text":"<p>Before diving in, ensure you have both NumPy and RustyNum installed:</p> <pre><code>pip install numpy rustynum\n</code></pre> <p>To measure execution times, you can use Python\u2019s built-in <code>time</code> module or other tools like <code>timeit</code> or IPython\u2019s <code>%timeit</code> magic command.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#key-operations","title":"Key Operations","text":"<p>Below are three core operations you can replace with RustyNum. Let\u2019s see how each one works with side-by-side comparisons.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#mean","title":"Mean","text":"<pre><code>import numpy as np\nimport rustynum as rnp\nimport time\n\n# Create test data\ndata_np = np.random.rand(1_000_000).astype(np.float32)\ndata_rn = rnp.NumArray(data_np.tolist(), dtype=\"float32\")\n\n# NumPy timing\nstart_np = time.time()\nmean_np = np.mean(data_np)\nend_np = time.time()\nnumpy_duration = end_np - start_np\n\n# RustyNum timing\nstart_rn = time.time()\nmean_rn = data_rn.mean().item()\nend_rn = time.time()\nrustynum_duration = end_rn - start_rn\n\n# Print results\nprint(\"Results Comparison:\")\nprint(\"-\" * 40)\nprint(f\"NumPy mean:    {mean_np:.8f}\")\nprint(f\"RustyNum mean: {mean_rn:.8f}\")\nprint(\"\\nPerformance:\")\nprint(\"-\" * 40)\nprint(f\"NumPy time:    {numpy_duration:.6f} seconds\")\nprint(f\"RustyNum time: {rustynum_duration:.6f} seconds\")\nprint(f\"Speedup:       {numpy_duration/rustynum_duration:.2f}x\")\n</code></pre> <p>On my MacBook Pro M1, this is the output:</p> <pre><code>Results Comparison:\n----------------------------------------\nNumPy mean:    0.50181508\nRustyNum mean: 0.50181526\n\nPerformance:\n----------------------------------------\nNumPy time:    0.000048 seconds\nRustyNum time: 0.000017 seconds\nSpeedup:       2.83x\n</code></pre> <p>Note</p> <p>The computed mean is slightly different between NumPy and RustyNum. This is due to the different underlying algorithms used by the two libraries.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#minimum","title":"Minimum","text":"<p><pre><code>import numpy as np\nimport rustynum as rnp\nimport time\n\n# Create test data\ndata_np = np.random.rand(100_000).astype(np.float32)\ndata_rn = rnp.NumArray(data_np.tolist(), dtype=\"float32\")\n\n# NumPy timing\nstart_np = time.time()\nmin_np = np.min(data_np)\nend_np = time.time()\nnumpy_duration = end_np - start_np\n\n# RustyNum timing\nstart_rn = time.time()\nmin_rn = data_rn.min()\nend_rn = time.time()\nrustynum_duration = end_rn - start_rn\n\n# Print results\nprint(\"Results Comparison:\")\nprint(\"-\" * 40)\nprint(f\"NumPy min:     {min_np:.8f}\")\nprint(f\"RustyNum min:  {min_rn:.8f}\")\nprint(\"\\nPerformance:\")\nprint(\"-\" * 40)\nprint(f\"NumPy time:    {numpy_duration:.6f} seconds\")\nprint(f\"RustyNum time: {rustynum_duration:.6f} seconds\")\nprint(f\"Speedup:       {numpy_duration/rustynum_duration:.2f}x\")\n</code></pre> On my MacBook Pro M1, this is the output: <pre><code>Results Comparison:\n----------------------------------------\nNumPy min:     0.00001837\nRustyNum min:  0.00001837\n\nPerformance:\n----------------------------------------\nNumPy time:    0.000033 seconds\nRustyNum time: 0.000010 seconds\nSpeedup:       3.29x\n</code></pre></p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#dot-product","title":"Dot Product","text":"<pre><code>import numpy as np\nimport rustynum as rnp\nimport time\n\n# Create test data\nmatrix_np = np.random.rand(1000, 1000).astype(np.float32)\nvector_np = np.random.rand(1000).astype(np.float32)\nmatrix_rn = rnp.NumArray(matrix_np.flatten().tolist(), dtype=\"float32\").reshape([1000, 1000])\nvector_rn = rnp.NumArray(vector_np.tolist(), dtype=\"float32\")\n\n# NumPy timing\nstart_np = time.time()\ndot_np = np.dot(matrix_np, vector_np)\nend_np = time.time()\nnumpy_duration = end_np - start_np\n\n# RustyNum timing\nstart_rn = time.time()\ndot_rn = matrix_rn.dot(vector_rn)\nend_rn = time.time()\nrustynum_duration = end_rn - start_rn\n\n# Print results\nprint(\"Results Comparison:\")\nprint(\"-\" * 40)\nprint(f\"NumPy dot[0]:    {dot_np[0]:.8f}\")\nprint(f\"RustyNum dot[0]: {dot_rn[0]:.8f}\")\nprint(\"\\nPerformance:\")\nprint(\"-\" * 40)\nprint(f\"NumPy time:    {numpy_duration:.6f} seconds\")\nprint(f\"RustyNum time: {rustynum_duration:.6f} seconds\")\nprint(f\"Speedup:       {numpy_duration/rustynum_duration:.2f}x\")\n</code></pre> <p>On my MacBook Pro M1, this is the output:</p> <pre><code>Results Comparison:\n----------------------------------------\nNumPy dot[0]:    251.67926025\nRustyNum dot[0]: 251.67927551\n\nPerformance:\n----------------------------------------\nNumPy time:    0.000353 seconds\nRustyNum time: 0.000093 seconds\nSpeedup:       3.79x\n</code></pre> <p>Note</p> <p>The computed dot product is slightly different between NumPy and RustyNum. This is due to the different underlying algorithms used by the two libraries.</p>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#putting-it-all-together","title":"Putting It All Together","text":"<p>By comparing performance for each operation, you can decide where RustyNum is most beneficial in your workflow. Some common findings:</p> <ul> <li>Larger arrays often highlight greater speedups with RustyNum.</li> <li>Repeated runs help confirm if performance gains are consistent.</li> <li>Float32 data types sometimes outperform float64 in RustyNum (depending on hardware and usage).</li> </ul>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#practical-tips","title":"Practical Tips","text":"<ol> <li>Batch Replacements: If you have multiple NumPy calls (e.g., mean, min, dot) in a single function, switching them all to RustyNum can yield a more substantial overall speedup.</li> <li>Benchmark Thoroughly: Profiling different array shapes and data types ensures you\u2019re optimizing the right operations.</li> <li>Mind the Overhead: For smaller arrays, overhead might reduce or negate speed gains.</li> </ol>"},{"location":"tutorials/replacing-numpy-for-faster-analytics/#next-steps","title":"Next Steps","text":"<ul> <li>Check out our API Reference for a complete list of functions and classes.</li> <li>Explore more advanced examples in our upcoming Tutorials.</li> <li>Contribute your own ideas or ask questions on our GitHub.</li> </ul> <p>Replacing essential NumPy functions with RustyNum can boost performance in many workloads. By running benchmarks on your own hardware, you\u2019ll see where RustyNum truly shines. Try it on real-world data and let us know how it goes!</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/","title":"Streamlining Machine Learning Preprocessing with RustyNum","text":"<p>Data preprocessing is a key step in machine learning. Whether you\u2019re prepping large datasets for neural networks or just cleaning up smaller ones, RustyNum can help speed up vectorized operations and transformations. In this tutorial, we\u2019ll explore how to use RustyNum for several preprocessing tasks, then show how to integrate your processed data with popular Python ML libraries.</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#introduction","title":"Introduction","text":"<p>When working with data, you often need to transform and prepare it for machine learning models. This can include scaling, normalizing, feature concatenation, and more. RustyNum offers a Python-friendly interface that can accelerate these tasks by leveraging Rust\u2019s SIMD optimizations. Let\u2019s look at how it works in practice.</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#environment-setup","title":"Environment Setup","text":"<p>Before starting, ensure you have RustyNum installed:</p> <pre><code>pip install rustynum\n</code></pre> <p>We\u2019ll also use NumPy for comparison and scikit-learn for a quick model integration step (optional):</p> <pre><code>pip install numpy scikit-learn\n</code></pre>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#loading-and-inspecting-data","title":"Loading and Inspecting Data","text":"<p>Let's start by importing all necessary libraries and creating our sample dataset:</p> <pre><code>import numpy as np\nimport rustynum as rnp\nimport math\nfrom sklearn.linear_model import LogisticRegression\n\n# Generate random data with shape (100, 3)\ndata_np = np.random.rand(100, 3).astype(np.float32)\n\n# Convert to RustyNum's NumArray\ndata_rn = rnp.NumArray(data_np.flatten().tolist(), dtype=\"float32\").reshape([100, 3])\n\nprint(\"RustyNum data shape:\", data_rn.shape)\n</code></pre> <p>Here, we create random data in NumPy, convert it to RustyNum, and confirm its shape. If you\u2019re loading a CSV, just convert that array to RustyNum similarly.</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#common-preprocessing-tasks","title":"Common Preprocessing Tasks","text":""},{"location":"tutorials/streamlining-machine-learning-preprocessing/#scaling","title":"Scaling","text":"<p>Scaling adjusts the range of features so they align more closely, which can help certain algorithms converge faster. Let\u2019s perform a simple min-max scale manually with RustyNum.</p> <ol> <li>Find the min and max for each column.  </li> <li>Subtract the min from each element.  </li> <li>Divide by (max - min).</li> </ol> <pre><code># Create a reusable scaling function\ndef min_max_scale(array):\n    # Step 1: Compute column-wise min and max\n    col_mins = []\n    col_maxes = []\n    for col_idx in range(array.shape[1]):\n        col_data = array[:, col_idx]\n        col_mins.append(col_data.min())\n        col_maxes.append(col_data.max())\n\n    # Step 2 &amp; 3: Scale each column\n    scaled_data = []\n    for col_idx in range(array.shape[1]):\n        col_data = array[:, col_idx]\n        numerator = col_data - col_mins[col_idx]\n        denominator = col_maxes[col_idx] - col_mins[col_idx] or 1.0\n        scaled_col = numerator / denominator\n        scaled_data.append(scaled_col.tolist())\n\n    # Concatenate scaled columns\n    return rnp.concatenate(\n        [rnp.NumArray(col, dtype=\"float32\").reshape([array.shape[0], 1]) for col in scaled_data],\n        axis=1\n    )\n\n# Scale our data\nscaled_data_rn = min_max_scale(data_rn)\nprint(\"Scaled data shape:\", scaled_data_rn.shape)\nprint(\"First row after scaling:\", scaled_data_rn[0, :].tolist())\n</code></pre> <p>Why Scale Before Normalizing?</p> <p>Scaling and normalization serve different purposes in your preprocessing pipeline:</p> <ul> <li>Scaling adjusts each feature to a common range, preventing any single feature from dominating</li> <li>Normalization adjusts each sample to have unit length, making samples comparable regardless of magnitude</li> </ul> <p>This combination is particularly useful for neural networks and distance-based algorithms where both feature balance and sample comparability matter.</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#normalization","title":"Normalization","text":"<p>Normalization transforms each sample to have unit norm. It\u2019s helpful in tasks such as text classification or when using distance-based metrics.</p> <pre><code>def l2_normalize(array):\n    rows = array.shape[0]\n    cols = array.shape[1]\n    result_list = []\n\n    for row_idx in range(rows):\n        row_data = array[row_idx, :].tolist()\n        norm = math.sqrt(sum(x*x for x in row_data))\n        norm = norm if norm != 0.0 else 1.0\n        normalized_row = [x / norm for x in row_data]\n        result_list.append(normalized_row)\n\n    return rnp.NumArray(result_list, dtype=\"float32\")\n\n# Normalize our scaled data\nnormalized_data_rn = l2_normalize(scaled_data_rn)\nprint(\"First row after L2 normalization:\", normalized_data_rn[0, :].tolist())\n</code></pre>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#concatenating-features","title":"Concatenating Features","text":"<p>If you have multiple feature sets (e.g., one from images, another from text), RustyNum can concatenate them into a single array:</p> <pre><code># Create two feature sets from our normalized data\nfeatures1 = normalized_data_rn[:, :2]  # First two columns\nfeatures2 = rnp.ones([100, 2])         # Additional features\n\n# Combine them\ncombined = rnp.concatenate([features1, features2], axis=1)\nprint(\"Combined feature shape:\", combined.shape)\n</code></pre>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#integrating-with-ml-libraries","title":"Integrating with ML Libraries","text":"<p>After scaling or normalizing, you can convert back to NumPy arrays for compatibility with libraries like scikit-learn:</p> <pre><code># Convert our preprocessed data back to NumPy\nX_train = np.array(normalized_data_rn.tolist(), dtype=np.float32)\n\n# Create dummy labels\ny_train = np.random.randint(0, 2, size=(100,))\n\n# Train a simple model\nmodel = LogisticRegression()\nmodel.fit(X_train, y_train)\n\nprint(\"Model coefficients:\", model.coef_)\n</code></pre> <p>This approach provides a quick path for ML experimentation.</p>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Batch Operations: RustyNum is most beneficial when dealing with whole arrays instead of looping element-by-element.  </li> <li>Consistent Data Types: Ensure your arrays use <code>float32</code> or <code>float64</code> as needed. Mixing types can cause errors.  </li> <li>Performance Testing: For large datasets, measure performance gains with profiling tools or benchmarks.  </li> </ol>"},{"location":"tutorials/streamlining-machine-learning-preprocessing/#next-steps","title":"Next Steps","text":"<ul> <li>Check out our other Tutorials for deeper dives into RustyNum\u2019s capabilities.  </li> <li>Review the API Reference for more advanced methods.  </li> <li>Join our community on GitHub Discussions to share ideas or ask questions.</li> </ul> <p>Preprocessing data can be a bottleneck in many ML pipelines. By harnessing RustyNum, you might reduce that overhead while still benefiting from a Python-friendly workflow. Give these techniques a try in your own projects and see how RustyNum fits into your machine learning stack!</p>"}]}